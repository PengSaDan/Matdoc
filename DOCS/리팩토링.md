# 리팩토링

- [리팩토링](#리팩토링)
  - [병원](#병원)
    - [병원검색](#-병원검색)
  - [약](#약)
    - [의약품 검색](#-의약품-검색)
    - [의약품 상세정보 출력](#-의약품-상세정보-출력)
    - [나의 약봉지 추가](#-나의-약봉지-추가)
    - [나의 약봉지 조회](#-나의-약봉지-조회)
    - [나의 약봉지 삭제](#-나의-약봉지-삭제)

## 병원

### 🏥 병원 검색

<details>
<summary>기존의 방법</summary>
<div markdown="1">

![병원검색old](/DOCS/images/capture/old/병원%20검색.png)

'이름으로 병원 검색' 과 '필터를 사용한 병원 검색' 으로 요청이 분리되어 있었습니다. 또한 '이름으로 병원 검색' 에서는 SQL의 `%like%`를 사용해 병원이름에 일치되는 병원

</div>
</details>

<img src="images/capture/new/병원 검색.png" width="60%"></img>

## 약

### 💊 의약품 검색

<details>
<summary>기존의 방법</summary>
<div markdown="1">

<img src="images/capture/old/의약품 검색.png" />

</div>
</details>

<br>

<b>새로운 방법</b>

<img src="images/capture/new/의약품 검색.png"  width="60%" />

기존에 if 문을 통해서 검색 조건을 구현하였습니다. if 문으로 구현할 경우 조건이 많아지면 if 문도 많아져 코드가 길어지는 단점이 있습니다. Querydsl을 이용하여 동적으로 쿼리를 작성하고 조건을 메서드로 만들어 유연한 설계가 가능했습니다.

```java
public List<Drug> searchDrug(DrugFilterReq d) {
    JPAQueryFactory query = querydslConfig.jpaQueryFactory();
    return query.select(drug)
        .from(drug)
        .where(filteringDrug(d), filteringColor(d))
        .fetch();
}
```

의약품 검색 조건으로는 이름, 색상, 모양, 분할선, 식별 문자가 있었습니다. 색상은 여러 개를 선택하여 or로 처리해야 했고, 다른 조건들은 하나씩 선택하여 and로 처리하기 위해 다른 조건들과 색상의 조건을 나눠 where 절에 넣었습니다.

```java
private BooleanBuilder filteringDrug(DrugFilterReq d) {
    BooleanBuilder builder = new BooleanBuilder();

    builder
        .and(nameSearch(d.getName()))
        .and(typeSearch(d.getType()))
        .and(lineSearch(d.getLine()))
        .and(markSearch(d.getMark()));

    return builder;
}

private BooleanBuilder filteringColor(DrugFilterReq d) {
    BooleanBuilder builder = new BooleanBuilder();

    String[] colors = d.getColors().split(",");
    for (String color : colors) {
        builder.or(colorSearch(color));
    }

    return builder;
}
```

각각의 조건들은 BooleanExpression으로 구현하였습니다. 조건의 입력을 String으로 받아 StringUtils 클래스의 hasText 메서드를 이용하여 값이 없을 경우 null을 반환하도록 구현했습니다.

```java
/**
 * 이름 검색
 */
private BooleanExpression nameSearch(String name) {
    return StringUtils.hasText(name) ? drug.drug_name.contains(name) : null;
}
```

<br>

### 🔍 의약품 상세정보 조회

<details>
<summary>기존의 방법</summary>
<div markdown="1">

<img src="images/capture/old/의약품 상세정보 출력.png" />

</div>
</details>

<br>

<b>새로운 방법</b>

<img src="images/capture/new/의약품 상세정보 출력.png" width="60%" />

의약품 번호로 해당 의약품의 상세정보를 조회하는 API를 구현하였습니다. 기존에는 하나의 의약품에 대한 상세정보를 조회하는 API가 세 개로 나누어져있어서 프론트에서 의약품 상세정보를 보기 위한 상세페이지에 진입할 때 서버와 세 번의 통신을 해야 했습니다. 한 번의 요청으로 프론트에서 효율적으로 state 관리를 하기 위해서 API를 한 개로 통합하였습니다.

### 🛒 나의 약봉지 추가

<details>
<summary>기존의 방법</summary>
<div markdown="1">

<img src="images/capture/old/나의 약봉지 추가.png" width="60%" />

</div>
</details>

<br>

<b>새로운 방법</b>

<img src="images/capture/new/나의 약봉지 추가.png" width="60%" />

유저가 약봉지를 만들어 제목, 내용을 입력하고 그에 포함되는 의약품들을 등록하여 관리할 수 있도록 구현하였습니다. 기존에는 의약품들을 for 문을 통해 추가하였습니다. 이를 Stream을 사용하여 간결하고 읽기 쉬운 코드로 개선하였습니다.

### 🩺 나의 약봉지 조회

<details>
<summary>기존의 방법</summary>
<div markdown="1">

<img src="images/capture/old/나의 약봉지 조회.png" />

</div>
</details>

<br>

<b>새로운 방법</b>

<img src="images/capture/new/나의 약봉지 조회.png" width="60%" />

유저가 만든 약봉지를 조회하는 API를 구현하였습니다. 기존에는 약봉지의 제목, 내용을 조회하는 API 하나와 약봉지에 포함된 의약품들을 조회하는 API 하나로 2개의 API로 나누어져 있었습니다. 성능을 개선하고 프론트에서 쉬운 state 관리를 위하여 두 개의 API를 하나로 통합하였습니다.

### 🩹 나의 약봉지 삭제

<details>
<summary>기존의 방법</summary>
<div markdown="1">

<img src="images/capture/old/나의 약봉지 삭제.png" width="60%" />

</div>
</details>

<br>

<b>새로운 방법</b>

<img src="images/capture/new/나의 약봉지 삭제.png" width="60%" />

등록한 약봉지를 삭제하는 API를 구현하였습니다. 기존에는 약봉지를 삭제하는 쿼리를 따로 작성하여 삭제 기능을 수행하고 있었습니다. 영속성 컨텍스트의 특징 중 하나인 변경 감지 기능을 적용해 보았습니다. 변경 감지는 트랜잭션 커밋 시 영속화된 Entity에서 가지고 있었던 최조 정보와 바뀐 Entity 정보를 비교해서 바뀐 부분을 update 해주는 기능입니다. 해당 메서드를 트랜잭션으로 묶고 약봉지에 대한 정보를 조회 후 해당 내용을 바꿔주었습니다. 메서드가 트랜잭션으로 묶여있기 때문에 메서드가 끝나는 지점에서 커밋이 발생하여 update 처리가 되었습니다.
